"""Tests targeting uncovered branch paths in exploit_mitigation_analyzer.py."""

from __future__ import annotations

from typing import Any

import pytest

from r2inspect.modules.exploit_mitigation_analyzer import ExploitMitigationAnalyzer


# ---------------------------------------------------------------------------
# Real stub adapter – no mock library
# ---------------------------------------------------------------------------


class StubAdapter:
    """
    Minimal real adapter returning configurable PE metadata
    without relying on any mock library.

    The infrastructure layer routes r2 commands to adapter methods:
      - "iHj"  -> get_pe_optional_header()
      - "iDj"  -> get_data_directories()
      - "ihj"  -> get_headers_json()
      - "iij"  -> get_imports()
      - "izzj" -> get_strings()
      - "iSj"  -> get_sections()
      - "pxj N @ addr" -> read_bytes_list(addr, N)
    """

    def __init__(
        self,
        pe_optional_header: dict | None = None,
        data_directories: list | None = None,
        headers_json: dict | list | None = None,
        imports: list | None = None,
        strings: list | None = None,
        sections: list | None = None,
        bytes_data: dict[int, list[int]] | None = None,
    ) -> None:
        self._pe_optional_header = pe_optional_header if pe_optional_header is not None else {}
        self._data_directories = data_directories if data_directories is not None else []
        self._headers_json = headers_json
        self._imports = imports if imports is not None else []
        self._strings = strings if strings is not None else []
        self._sections = sections if sections is not None else []
        self._bytes_data: dict[int, list[int]] = bytes_data or {}

    def get_pe_optional_header(self) -> dict:
        return self._pe_optional_header

    def get_data_directories(self) -> list:
        return self._data_directories

    def get_headers_json(self) -> dict | list | None:
        return self._headers_json

    def get_imports(self) -> list:
        return self._imports

    def get_strings(self) -> list:
        return self._strings

    def get_sections(self) -> list:
        return self._sections

    def read_bytes_list(self, address: int, size: int) -> list[int]:
        return self._bytes_data.get(address, [])


def _make_load_config_bytes(
    config_size: int = 200,
    security_cookie: int = 0xBAADF00D,
    guard_flags: int = 0,
    is_64bit: bool = False,
) -> list[int]:
    """Build a minimal load config byte array (256 bytes)."""
    data = [0] * 256
    # config_size at offset 0 (u32)
    data[0] = config_size & 0xFF
    data[1] = (config_size >> 8) & 0xFF
    data[2] = (config_size >> 16) & 0xFF
    data[3] = (config_size >> 24) & 0xFF
    # security_cookie at offset 60 (32-bit PE) or 88 (64-bit PE)
    cookie_off = 88 if is_64bit else 60
    data[cookie_off] = security_cookie & 0xFF
    data[cookie_off + 1] = (security_cookie >> 8) & 0xFF
    data[cookie_off + 2] = (security_cookie >> 16) & 0xFF
    data[cookie_off + 3] = (security_cookie >> 24) & 0xFF
    # guard_flags at offset 144 (64-bit) or 140 (32-bit)
    gf_off = 144 if is_64bit else 140
    data[gf_off] = guard_flags & 0xFF
    data[gf_off + 1] = (guard_flags >> 8) & 0xFF
    data[gf_off + 2] = (guard_flags >> 16) & 0xFF
    data[gf_off + 3] = (guard_flags >> 24) & 0xFF
    return data


# ---------------------------------------------------------------------------
# analyze() – exception path
# ---------------------------------------------------------------------------


def test_analyze_exception_path_sets_available_false() -> None:
    """The outer except in analyze() sets available=False and records error."""

    class ScoreThrowingAnalyzer(ExploitMitigationAnalyzer):
        """Causes an unhandled exception after the inner try blocks."""

        def _calculate_security_score(self, result: dict) -> None:
            raise RuntimeError("forced score error")

    adapter = StubAdapter(pe_optional_header={"dll_characteristics": 0})
    analyzer = ScoreThrowingAnalyzer(adapter=adapter)
    result = analyzer.analyze()
    assert result["available"] is False
    assert "error" in result
    assert "forced score error" in result["error"]
    assert result["mitigations"] == {}


# ---------------------------------------------------------------------------
# _check_dll_characteristics
# ---------------------------------------------------------------------------


def test_check_dll_characteristics_with_all_security_flags() -> None:
    """DYNAMIC_BASE | HIGH_ENTROPY_VA | NX_COMPAT | GUARD_CF all set."""
    flags = 0x0020 | 0x0040 | 0x0100 | 0x4000  # HIGH_ENTROPY_VA + DYNAMIC_BASE + NX_COMPAT + GUARD_CF
    adapter = StubAdapter(pe_optional_header={"dll_characteristics": flags})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)

    assert result["dll_characteristics"]["value"] == hex(flags)
    assert "DYNAMIC_BASE" in result["dll_characteristics"]["flags"]
    assert "HIGH_ENTROPY_VA" in result["dll_characteristics"]["flags"]
    assert "NX_COMPAT" in result["dll_characteristics"]["flags"]
    assert "GUARD_CF" in result["dll_characteristics"]["flags"]
    assert result["mitigations"]["ASLR"]["enabled"] is True
    assert result["mitigations"]["ASLR"]["high_entropy"] is True
    assert result["mitigations"]["DEP"]["enabled"] is True
    assert result["mitigations"]["CFG"]["enabled"] is True


def test_check_dll_characteristics_with_force_integrity_flag() -> None:
    adapter = StubAdapter(pe_optional_header={"dll_characteristics": 0x0080})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"]["Force_Integrity"]["enabled"] is True


def test_check_dll_characteristics_with_appcontainer_flag() -> None:
    adapter = StubAdapter(pe_optional_header={"dll_characteristics": 0x1000})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"]["AppContainer"]["enabled"] is True


def test_check_dll_characteristics_with_no_seh_flag() -> None:
    adapter = StubAdapter(pe_optional_header={"dll_characteristics": 0x0400})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"]["No_SEH"]["enabled"] is True


def test_check_dll_characteristics_with_zero_flags() -> None:
    adapter = StubAdapter(pe_optional_header={"dll_characteristics": 0})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    assert result["dll_characteristics"]["flags"] == {}
    assert result["mitigations"]["ASLR"]["enabled"] is False
    assert result["mitigations"]["DEP"]["enabled"] is False


def test_check_dll_characteristics_returns_early_when_header_empty() -> None:
    adapter = StubAdapter(pe_optional_header={})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    # Empty dict is falsy so the method returns early
    assert result["mitigations"] == {}


def test_check_dll_characteristics_returns_early_when_header_none() -> None:
    class NoneHeaderAdapter(StubAdapter):
        def get_pe_optional_header(self) -> None:
            return None

    adapter = NoneHeaderAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"] == {}


def test_check_dll_characteristics_exception_is_caught() -> None:
    class BadAdapter(StubAdapter):
        def get_pe_optional_header(self) -> dict:
            raise ValueError("bad header")

    adapter = BadAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {}}
    # Should not raise; exception is caught internally
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"] == {}


# ---------------------------------------------------------------------------
# _check_safe_seh
# ---------------------------------------------------------------------------


def test_check_safe_seh_sets_false_when_no_seh_flag_is_set() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {
        "mitigations": {},
        "dll_characteristics": {"flags": {"NO_SEH": True}},
    }
    analyzer._check_safe_seh(result)
    assert result["mitigations"]["SafeSEH"]["enabled"] is False
    assert "NO_SEH" in result["mitigations"]["SafeSEH"]["note"]


def test_check_safe_seh_sets_false_when_no_data_directories() -> None:
    class NoDataDirsAdapter(StubAdapter):
        def get_data_directories(self) -> list:
            return []

    adapter = NoDataDirsAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {"flags": {}}}
    analyzer._check_safe_seh(result)
    assert result["mitigations"]["SafeSEH"]["enabled"] is False


def test_check_safe_seh_sets_true_when_load_config_present() -> None:
    load_config_paddr = 0x500
    bytes_at_offset = list(range(64))  # 64 bytes -> >= 64
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": load_config_paddr, "vaddr": 0x1000}],
        bytes_data={load_config_paddr: bytes_at_offset},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {"flags": {}}}
    analyzer._check_safe_seh(result)
    assert result["mitigations"]["SafeSEH"]["enabled"] is True


def test_check_safe_seh_sets_false_when_load_config_data_too_short() -> None:
    load_config_paddr = 0x600
    short_bytes = list(range(10))  # < 64
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": load_config_paddr, "vaddr": 0x1000}],
        bytes_data={load_config_paddr: short_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {"flags": {}}}
    analyzer._check_safe_seh(result)
    assert result["mitigations"]["SafeSEH"]["enabled"] is False
    assert "No SafeSEH" in result["mitigations"]["SafeSEH"]["note"]


def test_check_safe_seh_sets_false_when_load_config_paddr_is_zero() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": 0, "vaddr": 0x1000}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {"flags": {}}}
    analyzer._check_safe_seh(result)
    assert result["mitigations"]["SafeSEH"]["enabled"] is False


def test_check_safe_seh_exception_sets_seh_with_error() -> None:
    class BrokenDirsAdapter(StubAdapter):
        def get_data_directories(self) -> None:
            raise RuntimeError("explosion")

    adapter = BrokenDirsAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "dll_characteristics": {"flags": {}}}
    analyzer._check_safe_seh(result)
    assert "SafeSEH" in result["mitigations"]
    assert result["mitigations"]["SafeSEH"]["enabled"] is False
    assert "error" in result["mitigations"]["SafeSEH"]


# ---------------------------------------------------------------------------
# _check_load_config
# ---------------------------------------------------------------------------


def test_check_load_config_sets_not_present_when_no_directories() -> None:
    adapter = StubAdapter(data_directories=[])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["present"] is False


def test_check_load_config_sets_not_present_when_vaddr_zero() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": 0x100, "vaddr": 0, "size": 200}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["present"] is False


def test_check_load_config_returns_early_when_paddr_zero() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": 0, "vaddr": 0x1000, "size": 200}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    # paddr=0 means early return, load_config stays as set before
    assert result["load_config"] == {}


def test_check_load_config_returns_early_when_size_zero() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": 0x100, "vaddr": 0x1000, "size": 0}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"] == {}


def test_check_load_config_returns_early_when_config_data_empty() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": 0x100, "vaddr": 0x1000, "size": 200}],
        bytes_data={0x100: []},  # empty list -> falsy
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"] == {}


def test_check_load_config_parses_valid_config_32bit() -> None:
    paddr = 0x200
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0xDEADBEEF,
        guard_flags=0,
        is_64bit=False,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["present"] is True
    assert result["load_config"]["security_cookie"] == hex(0xDEADBEEF)


def test_check_load_config_parses_valid_config_64bit() -> None:
    paddr = 0x300
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0xCAFEBABE,
        guard_flags=0,
        is_64bit=True,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32+"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["present"] is True
    assert result["load_config"]["security_cookie"] == hex(0xCAFEBABE)


def test_check_load_config_with_guard_cf_flags() -> None:
    paddr = 0x400
    guard_flags = 0x100 | 0x200  # cf_instrumented + cf_function_table_present
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0,
        guard_flags=guard_flags,
        is_64bit=False,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {"CFG": {}}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["guard_flags"]["cf_instrumented"] is True
    assert result["mitigations"]["CFG"]["enabled"] is True


def test_check_load_config_with_rfg_flags() -> None:
    paddr = 0x500
    guard_flags = 0x20000 | 0x40000  # rf_instrumented + rf_enable
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0,
        guard_flags=guard_flags,
        is_64bit=False,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["mitigations"]["RFG"]["enabled"] is True
    assert "and enabled" in result["mitigations"]["RFG"]["details"]


def test_check_load_config_with_rfg_instrumented_only() -> None:
    paddr = 0x600
    guard_flags = 0x20000  # rf_instrumented only (no rf_enable)
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0,
        guard_flags=guard_flags,
        is_64bit=False,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["mitigations"]["RFG"]["enabled"] is True
    assert "and enabled" not in result["mitigations"]["RFG"]["details"]


def test_check_load_config_skips_guard_flags_when_config_size_too_small() -> None:
    paddr = 0x700
    config_bytes = _make_load_config_bytes(
        config_size=100,  # < 148, so guard flags are skipped
        security_cookie=0xDEAD,
        guard_flags=0x100,
        is_64bit=False,
    )
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        pe_optional_header={"magic": "PE32"},
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert "guard_flags" not in result["load_config"]


def test_check_load_config_short_data_returns_minimal_config() -> None:
    paddr = 0x800
    short_bytes = [0] * 50  # < 92, triggers early return from _parse_load_config
    adapter = StubAdapter(
        data_directories=[{"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200}],
        bytes_data={paddr: short_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_load_config(result)
    assert result["load_config"]["present"] is True
    assert "structure_size" not in result["load_config"]


# ---------------------------------------------------------------------------
# _check_stack_cookies
# ---------------------------------------------------------------------------


def test_check_stack_cookies_from_load_config_security_cookie() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {
        "mitigations": {},
        "load_config": {"security_cookie": "0xdeadbeef"},
    }
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True
    assert result["mitigations"]["Stack_Cookies"]["cookie"] == "0xdeadbeef"


def test_check_stack_cookies_from_security_cookie_import() -> None:
    adapter = StubAdapter(imports=[{"name": "__security_cookie"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True
    assert "Security cookie imports found" in result["mitigations"]["Stack_Cookies"]["note"]


def test_check_stack_cookies_from_security_init_cookie_import() -> None:
    adapter = StubAdapter(imports=[{"name": "__security_init_cookie"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_check_stack_cookies_from_gs_indicator_in_strings() -> None:
    adapter = StubAdapter(strings=[{"string": "__GSHandlerCheck_is_present"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True
    assert "GS indicator found" in result["mitigations"]["Stack_Cookies"]["note"]


def test_check_stack_cookies_from_security_check_cookie_string() -> None:
    adapter = StubAdapter(strings=[{"string": "__security_check_cookie"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_check_stack_cookies_not_found_sets_disabled() -> None:
    adapter = StubAdapter(imports=[], strings=[])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is False
    assert "No stack cookie" in result["mitigations"]["Stack_Cookies"]["note"]


def test_has_security_cookie_imports_with_unrelated_imports() -> None:
    adapter = StubAdapter(imports=[{"name": "CreateFileW"}, {"name": "VirtualAlloc"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    # No cookie import -> falls through to GS check or disabled
    assert "Stack_Cookies" in result["mitigations"]


def test_find_gs_indicator_checks_first_100_strings() -> None:
    # Put the indicator at position 99 (within limit)
    strings = [{"string": "unrelated_string_value"}] * 99 + [{"string": "/GS_compiler_option"}]
    adapter = StubAdapter(strings=strings)
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "load_config": {}}
    analyzer._check_stack_cookies(result)
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_find_gs_indicator_returns_none_when_no_strings() -> None:
    adapter = StubAdapter(strings=[])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    indicator = analyzer._find_gs_indicator()
    assert indicator is None


# ---------------------------------------------------------------------------
# _check_authenticode
# ---------------------------------------------------------------------------


def test_check_authenticode_sets_enabled_when_security_dir_present() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "SECURITY", "vaddr": 0x9000, "size": 512}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    analyzer._check_authenticode(result)
    assert result["mitigations"]["Authenticode"]["enabled"] is True
    assert result["mitigations"]["Authenticode"]["size"] == 512


def test_check_authenticode_sets_disabled_when_security_dir_vaddr_zero() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "SECURITY", "vaddr": 0, "size": 512}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    analyzer._check_authenticode(result)
    assert result["mitigations"]["Authenticode"]["enabled"] is False
    assert "No certificate table found" in result["mitigations"]["Authenticode"]["note"]


def test_check_authenticode_sets_disabled_when_no_security_dir() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "EXPORT", "vaddr": 0x1000, "size": 100}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    analyzer._check_authenticode(result)
    assert result["mitigations"]["Authenticode"]["enabled"] is False


def test_check_authenticode_sets_disabled_when_no_data_dirs() -> None:
    adapter = StubAdapter(data_directories=[])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    analyzer._check_authenticode(result)
    assert result["mitigations"]["Authenticode"]["enabled"] is False
    assert "No data directories" in result["mitigations"]["Authenticode"]["note"]


def test_check_authenticode_skips_non_dict_entry_in_data_dirs() -> None:
    adapter = StubAdapter(
        data_directories=["not_a_dict", {"name": "SECURITY", "vaddr": 0xA000, "size": 200}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    analyzer._check_authenticode(result)
    assert result["mitigations"]["Authenticode"]["enabled"] is True


def test_check_authenticode_exception_is_caught() -> None:
    class BrokenDataDirs(StubAdapter):
        def get_data_directories(self) -> None:
            raise RuntimeError("data dirs broken")

    adapter = BrokenDataDirs()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}}
    # Should not raise
    analyzer._check_authenticode(result)


# ---------------------------------------------------------------------------
# _check_pe_security_features
# ---------------------------------------------------------------------------


def test_check_pe_security_features_returns_early_when_no_pe_header() -> None:
    class NoHeaderAdapter(StubAdapter):
        def get_headers_json(self) -> None:
            return None

    adapter = NoHeaderAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    assert result["vulnerabilities"] == []


def test_check_pe_security_features_with_list_pe_header_uses_first() -> None:
    pe_header = [{"characteristics": 0x2000}]
    optional = {"subsystem": "Windows GUI", "entry_point": 0x1000, "image_base": 0}
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
        sections=[{"name": ".text", "vaddr": 0x1000, "vsize": 0x5000, "perm": "--x-r"}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    assert "pe_info" in result
    assert result["pe_info"]["is_dll"] is True


def test_check_pe_security_features_records_vulnerability_when_relocs_stripped_and_aslr() -> None:
    pe_header = {"characteristics": 0x0001}  # relocs stripped
    optional = {"subsystem": "Windows CUI", "entry_point": 0, "image_base": 0}
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {
        "mitigations": {"ASLR": {"enabled": True}},
        "vulnerabilities": [],
    }
    analyzer._check_pe_security_features(result)
    issues = [v["issue"] for v in result["vulnerabilities"]]
    assert "ASLR ineffective" in issues


def test_check_pe_security_features_records_unusual_entry_point() -> None:
    pe_header = {"characteristics": 0}
    optional = {"subsystem": "Windows GUI", "entry_point": 0x5000, "image_base": 0}
    # Entry point 0x5000 falls in a non-executable section
    sections = [{"name": ".data", "vaddr": 0x4000, "vsize": 0x2000, "perm": "rw--"}]
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
        sections=sections,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    issues = [v["issue"] for v in result["vulnerabilities"]]
    assert "Unusual entry point" in issues


def test_check_pe_security_features_no_vulnerability_when_entry_in_exec_section() -> None:
    pe_header = {"characteristics": 0}
    optional = {"subsystem": "Windows GUI", "entry_point": 0x1000, "image_base": 0}
    sections = [{"name": ".text", "vaddr": 0x1000, "vsize": 0x5000, "perm": "--x-r"}]
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
        sections=sections,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    unusual_ep = [v for v in result["vulnerabilities"] if v["issue"] == "Unusual entry point"]
    assert unusual_ep == []


def test_check_pe_security_features_with_wx_section_entry_point() -> None:
    pe_header = {"characteristics": 0}
    optional = {"subsystem": "Windows GUI", "entry_point": 0x2000, "image_base": 0}
    sections = [{"name": ".text", "vaddr": 0x2000, "vsize": 0x1000, "perm": "-wx-"}]
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
        sections=sections,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    unusual_ep = [v for v in result["vulnerabilities"] if v["issue"] == "Unusual entry point"]
    assert unusual_ep == []


def test_check_pe_security_features_entry_point_rva_calculation() -> None:
    pe_header = {"characteristics": 0}
    # entry_point > image_base -> rva = entry_point - image_base
    optional = {"subsystem": "Windows GUI", "entry_point": 0x401000, "image_base": 0x400000}
    sections = [{"name": ".text", "vaddr": 0x1000, "vsize": 0x5000, "perm": "--x-r"}]
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
        sections=sections,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    # RVA = 0x1000, which is in .text -> no unusual entry point vulnerability
    unusual_ep = [v for v in result["vulnerabilities"] if v["issue"] == "Unusual entry point"]
    assert unusual_ep == []


def test_check_pe_security_features_sets_driver_flag_for_driver_subsystem() -> None:
    pe_header = {"characteristics": 0}
    optional = {"subsystem": "kernel_driver", "entry_point": 0, "image_base": 0}
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    if "pe_info" in result:
        assert result["pe_info"]["is_driver"] is True


def test_check_pe_security_features_empty_subsystem_does_not_set_pe_info() -> None:
    pe_header = {"characteristics": 0}
    optional = {"subsystem": "", "entry_point": 0, "image_base": 0}
    adapter = StubAdapter(
        headers_json=pe_header,
        pe_optional_header=optional,
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = {"mitigations": {}, "vulnerabilities": []}
    analyzer._check_pe_security_features(result)
    assert "pe_info" not in result


def test_get_pe_header_returns_none_when_false_header() -> None:
    class EmptyHeaderAdapter(StubAdapter):
        def get_headers_json(self) -> dict:
            return {}

    adapter = EmptyHeaderAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer._get_pe_header()
    assert result is None


def test_get_pe_header_returns_first_element_from_list() -> None:
    adapter = StubAdapter(headers_json=[{"characteristics": 0x22}, {"other": "data"}])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer._get_pe_header()
    assert result == {"characteristics": 0x22}


def test_get_pe_header_returns_none_from_empty_list() -> None:
    adapter = StubAdapter(headers_json=[])
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer._get_pe_header()
    assert result is None


# ---------------------------------------------------------------------------
# Helper methods
# ---------------------------------------------------------------------------


def test_safe_seh_entry_with_only_note() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    entry = analyzer._safe_seh_entry(enabled=True, note="test note")
    assert entry["enabled"] is True
    assert entry["note"] == "test note"
    assert "error" not in entry


def test_safe_seh_entry_with_only_error() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    entry = analyzer._safe_seh_entry(enabled=False, error="bad error")
    assert entry["enabled"] is False
    assert entry["error"] == "bad error"
    assert "note" not in entry


def test_safe_seh_entry_with_no_optional_fields() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    entry = analyzer._safe_seh_entry(enabled=True)
    assert entry["enabled"] is True
    assert "note" not in entry
    assert "error" not in entry


def test_stack_cookie_entry_with_all_fields() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    entry = analyzer._stack_cookie_entry(enabled=True, cookie="0xdeadbeef", note="found it")
    assert entry["enabled"] is True
    assert entry["cookie"] == "0xdeadbeef"
    assert entry["note"] == "found it"


def test_stack_cookie_entry_minimal() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    entry = analyzer._stack_cookie_entry(enabled=False)
    assert entry["enabled"] is False
    assert "cookie" not in entry
    assert "note" not in entry


def test_coerce_dict_list_with_dict_input() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = ExploitMitigationAnalyzer._coerce_dict_list({"key": "value"})
    assert result == [{"key": "value"}]


def test_coerce_dict_list_with_non_dict_non_list() -> None:
    result = ExploitMitigationAnalyzer._coerce_dict_list("string_input")
    assert result == []


def test_coerce_dict_list_filters_non_dict_from_list() -> None:
    result = ExploitMitigationAnalyzer._coerce_dict_list([{"a": 1}, "string", 42, {"b": 2}])
    assert result == [{"a": 1}, {"b": 2}]


def test_get_load_config_dir_returns_none_when_no_matching_entry() -> None:
    adapter = StubAdapter(
        data_directories=[{"name": "EXPORT", "paddr": 100, "vaddr": 0x1000}],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer._get_load_config_dir()
    assert result is None


def test_get_load_config_dir_returns_entry_when_found() -> None:
    adapter = StubAdapter(
        data_directories=[
            {"name": "EXPORT", "paddr": 100},
            {"name": "LOAD_CONFIG", "paddr": 200, "vaddr": 0x2000},
        ],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer._get_load_config_dir()
    assert result is not None
    assert result["name"] == "LOAD_CONFIG"


def test_is_pe_64bit_returns_true_for_pe32plus() -> None:
    adapter = StubAdapter(pe_optional_header={"magic": "PE32+"})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    assert analyzer._is_pe_64bit() is True


def test_is_pe_64bit_returns_false_for_pe32() -> None:
    adapter = StubAdapter(pe_optional_header={"magic": "PE32"})
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    assert analyzer._is_pe_64bit() is False


def test_read_u32_correctly_decodes_little_endian() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    data = [0x78, 0x56, 0x34, 0x12]
    assert analyzer._read_u32(data, 0) == 0x12345678


def test_entry_point_in_exec_section_returns_false_for_no_match() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    sections = [{"vaddr": 0x1000, "vsize": 0x100, "perm": "r--"}]
    assert analyzer._entry_point_in_exec_section(sections, 0x9000) is False


def test_entry_point_in_exec_section_returns_false_for_non_exec_perm() -> None:
    adapter = StubAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    sections = [{"vaddr": 0x1000, "vsize": 0x5000, "perm": "rw--"}]
    assert analyzer._entry_point_in_exec_section(sections, 0x1000) is False


# ---------------------------------------------------------------------------
# Full analyze() integration – covers most of the flow
# ---------------------------------------------------------------------------


def test_analyze_full_with_all_mitigations_enabled() -> None:
    flags = 0x0060 | 0x0100 | 0x4000  # DYNAMIC_BASE + HIGH_ENTROPY_VA + NX_COMPAT + GUARD_CF
    paddr = 0x100
    config_bytes = _make_load_config_bytes(
        config_size=200,
        security_cookie=0xDEADBEEF,
        guard_flags=0x100,
        is_64bit=False,
    )
    adapter = StubAdapter(
        pe_optional_header={"dll_characteristics": flags, "magic": "PE32"},
        data_directories=[
            {"name": "LOAD_CONFIG", "paddr": paddr, "vaddr": 0x1000, "size": 200},
            {"name": "SECURITY", "vaddr": 0x9000, "size": 512},
        ],
        headers_json={"characteristics": 0x0002},
        sections=[{"name": ".text", "vaddr": 0x1000, "vsize": 0x5000, "perm": "--x-r"}],
        bytes_data={paddr: config_bytes},
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer.analyze()
    assert result["available"] is True
    assert "mitigations" in result
    assert "security_score" in result
    assert "recommendations" in result


def test_analyze_full_with_no_mitigations() -> None:
    adapter = StubAdapter(
        pe_optional_header={"dll_characteristics": 0, "magic": "PE32"},
        data_directories=[],
        headers_json={"characteristics": 0},
        sections=[],
    )
    analyzer = ExploitMitigationAnalyzer(adapter=adapter)
    result = analyzer.analyze()
    assert result["available"] is True
    assert result["mitigations"]["ASLR"]["enabled"] is False
    assert result["mitigations"]["DEP"]["enabled"] is False
    assert len(result["recommendations"]) > 0
