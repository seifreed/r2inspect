"""Comprehensive tests for exploit mitigation analyzer - 0% coverage target"""
import pytest

from r2inspect.modules.exploit_mitigation_analyzer import ExploitMitigationAnalyzer


class MockAdapter:
    """Mock adapter for testing"""

    def __init__(self, responses=None):
        self.responses = responses or {}
        self.cmds = []

    def cmdj(self, cmd, default=None):
        self.cmds.append(cmd)
        return self.responses.get(cmd, default)

    def cmd(self, cmd):
        self.cmds.append(cmd)
        return self.responses.get(cmd, "")

    def get_imports(self):
        return self.responses.get("imports", [])

    def get_strings(self):
        return self.responses.get("strings", [])

    def get_sections(self):
        return self.responses.get("sections", [])

    def read_bytes(self, addr, size):
        return self.responses.get(f"bytes_{addr}_{size}", b"")


def test_exploit_mitigation_basic_structure():
    adapter = MockAdapter()
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    assert "mitigations" in result
    assert "dll_characteristics" in result
    assert "load_config" in result
    assert "security_score" in result
    assert "recommendations" in result
    assert "vulnerabilities" in result


def test_dll_characteristics_parsing():
    adapter = MockAdapter({
        "iHj": {
            "dll_characteristics": 0x8160,  # DYNAMIC_BASE | NX_COMPAT | TERMINAL_SERVER_AWARE
        }
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["dll_characteristics"]["value"] == hex(0x8160)
    assert "DYNAMIC_BASE" in result["dll_characteristics"]["flags"]
    assert result["mitigations"]["ASLR"]["enabled"] is True
    assert result["mitigations"]["DEP"]["enabled"] is True


def test_dll_characteristics_all_flags():
    adapter = MockAdapter({
        "iHj": {
            "dll_characteristics": 0xFFFF,
        }
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["ASLR"]["enabled"] is True
    assert result["mitigations"]["ASLR"]["high_entropy"] is True
    assert result["mitigations"]["DEP"]["enabled"] is True
    assert result["mitigations"]["CFG"]["enabled"] is True
    assert result["mitigations"]["Force_Integrity"]["enabled"] is True
    assert result["mitigations"]["AppContainer"]["enabled"] is True
    assert result["mitigations"]["No_SEH"]["enabled"] is True


def test_dll_characteristics_no_optional_header():
    adapter = MockAdapter({"iHj": None})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    assert result["mitigations"] == {}


def test_dll_characteristics_invalid_type():
    adapter = MockAdapter({"iHj": "invalid"})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    assert result["mitigations"] == {}


def test_safe_seh_with_no_seh_flag():
    adapter = MockAdapter({
        "iHj": {"dll_characteristics": 0x0400},  # NO_SEH
        "iDj": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["SafeSEH"]["enabled"] is False
    assert "NO_SEH" in result["mitigations"]["SafeSEH"]["note"]


def test_safe_seh_no_data_directories():
    adapter = MockAdapter({"iHj": {}, "iDj": None})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["SafeSEH"]["enabled"] is False


def test_safe_seh_with_load_config():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 64}],
        "pxj 64 @ 0x1000": [0] * 64,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["SafeSEH"]["enabled"] is True


def test_safe_seh_error_handling():
    adapter = MockAdapter({"iHj": {}, "iDj": []})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    assert "SafeSEH" in result["mitigations"]


def test_load_config_not_present():
    adapter = MockAdapter({"iHj": {}, "iDj": []})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["present"] is False


def test_load_config_zero_vaddr():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0, "vaddr": 0, "size": 0}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["present"] is False


def test_load_config_32bit_parsing():
    config_data = [0x5C, 0, 0, 0] + [0] * 88  # Size field + padding
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        f"pxj 92 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["present"] is True
    assert result["load_config"]["structure_size"] == 0x5C


def test_load_config_64bit_parsing():
    config_data = [0x94, 0, 0, 0] + [0] * 144  # Size field + padding
    adapter = MockAdapter({
        "iHj": {"magic": "PE32+"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 148}],
        f"pxj 148 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["present"] is True
    assert result["load_config"]["structure_size"] == 0x94


def test_load_config_guard_flags():
    config_data = [0x94, 0, 0, 0] + [0] * 140 + [0x00, 0x01, 0x00, 0x00]  # CF_INSTRUMENTED
    adapter = MockAdapter({
        "iHj": {"magic": "PE32+"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 148}],
        f"pxj 148 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["guard_flags"]["cf_instrumented"] is True
    assert result["mitigations"]["CFG"]["enabled"] is True


def test_load_config_rfg_flags():
    config_data = [0x94, 0, 0, 0] + [0] * 140 + [0x00, 0x00, 0x02, 0x00]  # RF_INSTRUMENTED
    adapter = MockAdapter({
        "iHj": {"magic": "PE32+"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 148}],
        f"pxj 148 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["guard_flags"]["rf_instrumented"] is True
    assert result["mitigations"]["RFG"]["enabled"] is True


def test_stack_cookies_from_load_config():
    config_data = [0x5C, 0, 0, 0] + [0] * 56 + [0xBB, 0x40, 0x00, 0x00] + [0] * 28
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        f"pxj 92 @ 0x1000": config_data,
        "imports": [],
        "strings": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True
    assert "cookie" in result["mitigations"]["Stack_Cookies"]


def test_stack_cookies_from_imports():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [{"name": "__security_init_cookie"}],
        "strings": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_stack_cookies_from_gs_indicator():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [],
        "strings": [{"string": "__GSHandlerCheck"}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_stack_cookies_not_found():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [],
        "strings": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is False


def test_authenticode_present():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "SECURITY", "vaddr": 0x5000, "size": 1024}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Authenticode"]["enabled"] is True
    assert result["mitigations"]["Authenticode"]["size"] == 1024


def test_authenticode_not_present():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "SECURITY", "vaddr": 0, "size": 0}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Authenticode"]["enabled"] is False


def test_authenticode_no_data_dirs():
    adapter = MockAdapter({"iHj": {}, "iDj": None})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Authenticode"]["enabled"] is False


def test_pe_security_relocations_stripped_with_aslr():
    adapter = MockAdapter({
        "iHj": {"dll_characteristics": 0x0040},  # DYNAMIC_BASE
        "ihj": {"characteristics": 0x0001},  # RELOCS_STRIPPED
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert len(result["vulnerabilities"]) > 0
    assert any("ASLR ineffective" in v["issue"] for v in result["vulnerabilities"])


def test_pe_security_entry_point_not_in_exec_section():
    adapter = MockAdapter({
        "iHj": {
            "entry_point": 0x401000,
            "image_base": 0x400000,
            "dll_characteristics": 0,
        },
        "ihj": {"characteristics": 0},
        "iSj": [
            {"vaddr": 0x1000, "vsize": 0x1000, "perm": "m-w"}  # Not executable
        ],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert any("Unusual entry point" in v["issue"] for v in result["vulnerabilities"])


def test_pe_security_entry_point_in_exec_section():
    adapter = MockAdapter({
        "iHj": {
            "entry_point": 0x401000,
            "image_base": 0x400000,
            "dll_characteristics": 0,
        },
        "ihj": {"characteristics": 0},
        "sections": [
            {"vaddr": 0x1000, "vsize": 0x1000, "perm": "--x"}  # Executable
        ],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    vulns = [v for v in result["vulnerabilities"] if "Unusual entry point" in v["issue"]]
    assert len(vulns) == 0


def test_pe_info_subsystem():
    adapter = MockAdapter({
        "iHj": {"subsystem": "WINDOWS_GUI", "dll_characteristics": 0},
        "ihj": {"characteristics": 0x2000},  # DLL
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["pe_info"]["subsystem"] == "WINDOWS_GUI"
    assert result["pe_info"]["is_dll"] is True


def test_pe_info_driver():
    adapter = MockAdapter({
        "iHj": {"subsystem": "NATIVE_DRIVER", "dll_characteristics": 0},
        "ihj": {"characteristics": 0},
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["pe_info"]["is_driver"] is True


def test_coerce_dict_list_with_list():
    result = ExploitMitigationAnalyzer._coerce_dict_list([{"a": 1}, "invalid", {"b": 2}])
    assert len(result) == 2
    assert result[0] == {"a": 1}
    assert result[1] == {"b": 2}


def test_coerce_dict_list_with_dict():
    result = ExploitMitigationAnalyzer._coerce_dict_list({"a": 1})
    assert result == [{"a": 1}]


def test_coerce_dict_list_with_invalid():
    result = ExploitMitigationAnalyzer._coerce_dict_list("invalid")
    assert result == []


def test_get_imports_from_adapter():
    adapter = MockAdapter({"imports": [{"name": "CreateFile"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_imports()
    assert len(result) == 1
    assert result[0]["name"] == "CreateFile"


def test_get_imports_fallback():
    adapter = MockAdapter({"iij": [{"name": "ReadFile"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_imports()
    assert len(result) == 1


def test_get_strings_from_adapter():
    adapter = MockAdapter({"strings": [{"string": "test"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_strings()
    assert len(result) == 1


def test_get_strings_fallback():
    adapter = MockAdapter({"izzj": [{"string": "fallback"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_strings()
    assert len(result) == 1


def test_get_sections_from_adapter():
    adapter = MockAdapter({"sections": [{"name": ".text"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_sections()
    assert len(result) == 1


def test_get_sections_fallback():
    adapter = MockAdapter({"iSj": [{"name": ".data"}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_sections()
    assert len(result) == 1


def test_analyze_error_handling():
    adapter = MockAdapter()
    adapter.cmdj = lambda cmd, default: (_ for _ in ()).throw(RuntimeError("Error"))
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["available"] is False
    assert "error" in result


def test_check_dll_characteristics_error():
    adapter = MockAdapter()
    adapter.cmdj = lambda cmd, default: (_ for _ in ()).throw(RuntimeError("Error"))
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = {"mitigations": {}}
    analyzer._check_dll_characteristics(result)
    assert result["mitigations"] == {}


def test_pe_header_as_list():
    adapter = MockAdapter({"ihj": [{"characteristics": 0x0001}]})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_pe_header()
    assert result == {"characteristics": 0x0001}


def test_pe_header_empty_list():
    adapter = MockAdapter({"ihj": []})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_pe_header()
    assert result is None


def test_pe_header_invalid_type():
    adapter = MockAdapter({"ihj": "invalid"})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._get_pe_header()
    assert result is None


def test_entry_point_calculation_with_image_base():
    adapter = MockAdapter({"iHj": {}, "ihj": {}, "sections": []})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = {"vulnerabilities": []}
    
    optional_header = {"entry_point": 0x402000, "image_base": 0x400000}
    analyzer._check_entry_point_section(result, optional_header)
    # Entry RVA should be 0x2000, not in any section
    assert len(result["vulnerabilities"]) > 0


def test_entry_point_lower_than_image_base():
    adapter = MockAdapter({"iHj": {}, "ihj": {}, "sections": []})
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = {"vulnerabilities": []}
    
    optional_header = {"entry_point": 0x1000, "image_base": 0x400000}
    analyzer._check_entry_point_section(result, optional_header)
    # Entry RVA should be 0x1000 (used as-is)
    assert len(result["vulnerabilities"]) > 0


def test_entry_point_writable_exec_permission():
    adapter = MockAdapter({
        "sections": [
            {"vaddr": 0x1000, "vsize": 0x2000, "perm": "-wx"}
        ]
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer._entry_point_in_exec_section([{"vaddr": 0x1000, "vsize": 0x2000, "perm": "-wx"}], 0x1500)
    assert result is True


def test_load_config_insufficient_data():
    config_data = [0] * 80  # Less than 92 bytes
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        f"pxj 92 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["present"] is True
    # Should not have structure_size if data too short


def test_load_config_small_size():
    config_data = [0x40, 0, 0, 0] + [0] * 88  # Size 64, less than threshold for guard flags
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        f"pxj 92 @ 0x1000": config_data,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["load_config"]["structure_size"] == 0x40
    # Should not have guard_flags


def test_security_cookie_64bit():
    config_data = [0x94, 0, 0, 0] + [0] * 84 + [0xBB, 0x40, 0x00, 0x00] + [0] * 56
    adapter = MockAdapter({
        "iHj": {"magic": "PE32+"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 148}],
        f"pxj 148 @ 0x1000": config_data,
        "imports": [],
        "strings": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    # 64-bit cookie offset is 88
    assert "Stack_Cookies" in result["mitigations"]


def test_has_security_cookie_imports_multiple():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [
            {"name": "__security_cookie"},
            {"name": "other_import"},
            {"name": "__SECURITY_INIT_COOKIE"},  # Case insensitive
        ],
        "strings": [],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_find_gs_indicator_security_check_cookie():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [],
        "strings": [{"string": "__security_check_cookie"}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_find_gs_indicator_gs_flag():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [],
        "strings": [{"string": "compiled with /GS"}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_find_gs_indicator_limit_strings():
    strings = [{"string": f"string_{i}"} for i in range(200)]
    strings[50]["string"] = "__GSHandlerCheck"
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [],
        "imports": [],
        "strings": strings,
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    
    # Should find indicator within first 100 strings
    assert result["mitigations"]["Stack_Cookies"]["enabled"] is True


def test_load_config_invalid_paddr():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0, "vaddr": 0x401000, "size": 64}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = {"load_config": {}}
    analyzer._check_load_config(result)
    # Should not process if paddr is 0


def test_load_config_zero_size():
    adapter = MockAdapter({
        "iHj": {},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 0}],
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = {"load_config": {}}
    analyzer._check_load_config(result)
    # Should not process if size is 0


def test_load_config_read_failure():
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        "pxj 92 @ 0x1000": None,  # Read failure
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    # Should handle gracefully


def test_load_config_invalid_data_type():
    adapter = MockAdapter({
        "iHj": {"magic": "PE32"},
        "iDj": [{"name": "LOAD_CONFIG", "paddr": 0x1000, "vaddr": 0x401000, "size": 92}],
        "pxj 92 @ 0x1000": "invalid",  # Wrong type
    })
    analyzer = ExploitMitigationAnalyzer(adapter)
    result = analyzer.analyze()
    # Should handle gracefully
